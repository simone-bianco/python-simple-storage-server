# Dolphin Storage Server - Architecture Documentation

A lightweight Flask-based file storage server designed as a fallback storage solution for RunPod workers processing PDF files.

## Overview

The Dolphin Storage Server provides a simple, secure, and ephemeral file storage for ZIP archives generated by RunPod workers. It's designed to be deployed on Hetzner or any VPS provider as a fallback storage when primary callback mechanisms fail.

---

## System Architecture

```mermaid
flowchart TB
    subgraph RunPod["RunPod Workers"]
        W1["Worker 1"]
        W2["Worker 2"]
        WN["Worker N"]
    end

    subgraph Server["Dolphin Storage Server"]
        API["Flask API"]
        DB[("SQLite DB")]
        FS[("File Storage")]
    end

    subgraph Clients["Download Clients"]
        C1["Client App"]
        C2["Admin Dashboard"]
    end

    W1 -->|"POST /upload"| API
    W2 -->|"POST /upload"| API
    WN -->|"POST /upload"| API

    API --> DB
    API --> FS

    C1 -->|"GET /download/{job_id}"| API
    C2 -->|"GET /list"| API
    C2 -->|"DELETE /delete/{job_id}"| API
```

---

## Application Flow

### Upload Flow

```mermaid
sequenceDiagram
    participant Worker as RunPod Worker
    participant API as Flask API
    participant Auth as Auth Decorator
    participant DB as SQLite
    participant FS as File Storage

    Worker->>API: POST /upload (ZIP + job_id)
    API->>Auth: Validate API Key
    Auth-->>API: OK

    alt Multipart Form
        API->>API: Extract file from form
    else Raw Binary
        API->>API: Read raw data + X-Job-Id header
    end

    API->>FS: Save ZIP to {job_id}.zip
    API->>DB: INSERT/UPDATE file record
    API-->>Worker: 201 Created + download_url
```

### Download Flow

```mermaid
sequenceDiagram
    participant Client as Client App
    participant API as Flask API
    participant DB as SQLite
    participant FS as File Storage

    Client->>API: GET /download/{job_id}
    API->>DB: SELECT file record
    DB-->>API: file_path, deleted status

    alt File Not Found
        API-->>Client: 404 Not Found
    else File Already Deleted
        API-->>Client: 410 Gone
    else File Exists
        API->>DB: UPDATE downloaded_at
        API->>Client: Send ZIP file

        alt AUTO_DELETE=true AND keep=false
            API->>FS: Delete file (async)
            API->>DB: SET deleted=TRUE
        end
    end
```

---

## Component Architecture

```mermaid
flowchart LR
    subgraph Core["Core Components"]
        APP["Flask App - app.py"]
        CONF["Configuration - .env"]
    end

    subgraph Storage["Data Layer"]
        SQLITE["SQLite Database - storage.db"]
        FILES["File System - /data/storage/"]
    end

    subgraph Infra["Infrastructure"]
        DOCKER["Docker Container"]
        NGINX["Nginx Reverse Proxy"]
    end

    Core --> Storage
    DOCKER --> Core
    NGINX --> DOCKER
```

---

## API Endpoints

| Endpoint             | Method | Auth Required | Description                   |
| -------------------- | ------ | ------------- | ----------------------------- |
| `/health`            | GET    | ❌            | Health check endpoint         |
| `/upload`            | POST   | ✅            | Upload ZIP file with job_id   |
| `/download/{job_id}` | GET    | ✅            | Download ZIP file by job_id   |
| `/delete/{job_id}`   | DELETE | ✅            | Manually delete a file        |
| `/list`              | GET    | ✅            | List all stored files (admin) |

---

## Database Schema

```mermaid
erDiagram
    FILES {
        TEXT job_id PK "Primary Key - Unique job identifier"
        TEXT file_path "Absolute path to ZIP file"
        INTEGER file_size "File size in bytes"
        TIMESTAMP uploaded_at "Upload timestamp"
        TIMESTAMP downloaded_at "Download timestamp (nullable)"
        BOOLEAN deleted "Soft delete flag"
    }
```

---

## Authentication

The server uses API Key authentication. The key can be provided in two ways:

1. **X-API-Key Header**: `X-API-Key: your-api-key`
2. **Authorization Bearer Token**: `Authorization: Bearer your-api-key`

```mermaid
flowchart TD
    REQ["Incoming Request"]
    CHECK{"Has X-API-Key or Bearer Token?"}
    VALID{"Key matches STORAGE_API_KEY?"}
    OK["Allow Request"]
    DENY["401 Unauthorized"]

    REQ --> CHECK
    CHECK -->|No| DENY
    CHECK -->|Yes| VALID
    VALID -->|No| DENY
    VALID -->|Yes| OK
```

---

## Configuration

### Environment Variables

| Variable          | Default                             | Description                 |
| ----------------- | ----------------------------------- | --------------------------- |
| `STORAGE_API_KEY` | `change-me-in-production`           | API key for authentication  |
| `STORAGE_PATH`    | `./storage` / `/data/storage`       | Directory for ZIP files     |
| `DATABASE_PATH`   | `./storage.db` / `/data/storage.db` | SQLite database path        |
| `PORT`            | `5000`                              | Server listening port       |
| `AUTO_DELETE`     | `true`                              | Delete files after download |
| `DEBUG`           | `false`                             | Enable Flask debug mode     |

---

## Deployment Architecture

```mermaid
flowchart TB
    CLIENT["Client Applications"]
    NGINX["Nginx Reverse Proxy + SSL"]
    GUNICORN["Gunicorn 2 Workers"]
    FLASK["Flask App"]
    VOLUME[("Docker Volume")]

    CLIENT -->|"HTTPS:443"| NGINX
    NGINX -->|"HTTP:5000"| GUNICORN
    GUNICORN --> FLASK
    FLASK --> VOLUME
```

---

## File Lifecycle

```mermaid
stateDiagram-v2
    [*] --> Uploaded: POST /upload

    Uploaded --> Downloaded: GET /download (keep=true)
    Uploaded --> AutoDeleted: GET /download (AUTO_DELETE=true)
    Uploaded --> ManuallyDeleted: DELETE /delete

    Downloaded --> Downloaded: GET /download (keep=true)
    Downloaded --> AutoDeleted: GET /download (AUTO_DELETE=true)
    Downloaded --> ManuallyDeleted: DELETE /delete

    AutoDeleted --> [*]
    ManuallyDeleted --> [*]
```

---

## Error Handling

| Status Code        | Scenario                        |
| ------------------ | ------------------------------- |
| `200 OK`           | Successful download/delete/list |
| `201 Created`      | Successful upload               |
| `400 Bad Request`  | Missing job_id or file data     |
| `401 Unauthorized` | Invalid or missing API key      |
| `404 Not Found`    | Job not found or file missing   |
| `410 Gone`         | File already deleted            |

---

## Testing

The application includes a comprehensive test suite using pytest:

```bash
# Install test dependencies
pip install -r requirements.txt -r tests/requirements-test.txt

# Run tests
pytest tests/ -v

# Run with coverage
pytest tests/ --cov=app --cov-report=html
```

### Test Coverage

- **Health**: Health endpoint availability
- **Authentication**: API key validation for all protected endpoints
- **Upload**: Multipart form and raw binary uploads
- **Download**: File retrieval with keep/auto-delete options
- **Delete**: Manual file deletion
- **List**: Admin file listing

---

## Security Considerations

1. **API Key Protection**: Never commit API keys; use environment variables
2. **SSL/TLS**: Always deploy behind nginx with Let's Encrypt SSL
3. **Rate Limiting**: Consider adding rate limiting for production
4. **File Validation**: Consider adding file type/size validation
5. **Log Monitoring**: Monitor logs for unauthorized access attempts
